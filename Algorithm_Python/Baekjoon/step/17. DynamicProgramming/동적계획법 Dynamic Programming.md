## 동적계획법 Dynamic Programming



##### 하나의 큰 문제를 여러개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결 할때 사용



- 연산이 반복되는 결점을 보완하기 위해서 동적계획법 고안됨.

- 원리는 처음 진행되는 연산을 기록해두고 이미 진행했던 연산은 다시 하는것이 아니라, 기록되어 있는 값 가져옴
- 큰 문제를 작은 문제로 쪼개서 답을 저장하고 재활용한다라고 해서 > **기억하며 풀기** 라고도 부름



**DP쓰는 이유**

- 재귀와 DP는 매우 유사 But  차이점은 재귀는 작은 문제들이 여러번 반복되어 비효율적으로 계산됨





> 동적 계획법 등장 배경 **'피보나치 수열'**

  제2항까지는 1, 제3항부터는 바로 앞의 두 항을 더한 수로 정의됩니다. 제0항은 생략하기도 합니다.

```
(0), 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...
```

피보나치 수열은 보통 재귀를 통해 표현하고 n번째 수를 구하는 함수

```python
int fibo(int n)
  {
    if (n<=2)
      return 1;
    else
      return fibo(n-1) + fibo(n-2);
   }
```

-  **return fibo(n-1)+fibo(n-2)**









> 사용조건



1. 겹치는 부분

   : 동일한 작은 문제들이 반복하여 나타나는 경우

2. 최적 부분 구조

   : 부분 문제의 최적 결과값을 사용해 전체 문제의 최적 결과를 낼수 있는 경우



**DP는 특정한 경우에 사용하는 알고리즘이 아니라 , 하나의 방법론이므로 다양한 문제 해결에 쓰일수 있음** 그래서 DP를 적용할수 있는 문제인지 알아내는 것 부터 파악해야함!

**1) DP로 풀 수 있는 문제인지 확인한다.**

**2)문제의 변수파악**

**3)변수간 관계식 만들기(점화식)**

**4)메모하기**

:변수 간 관계식까지 정상적으로 생성되었다면 **변수의 값에 따른 결과를 저장**해야 한다. 이것을 메모한다고 하여 **Memoization**이라고 부른다.

**5)기저 상태 파악하기**

:**가장 작은 문제의 상태를 알아야** 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다.  **피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식**이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.





**6)구현하기**



-Bottom-Up (Tabulation 방식) - 반복문 사용

: **아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식**

-Top-Down (Memoization 방식) - 재귀 사용

:**위에서 부터 바로 호출을 시작**하여 dp[0]의 상태까지 내려간 다음 해당 **결과 값을 재귀를 통해 전이시켜 재활용하는 방식**이다.





























참고

https://hongjw1938.tistory.com/47

https://velog.io/@chelsea/1-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming-DP

